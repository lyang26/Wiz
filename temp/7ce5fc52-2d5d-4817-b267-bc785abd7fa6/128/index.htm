<!DOCTYPE HTML><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=unicode">
<title>HashMap实现原理和底层数据结构</title>
    <!--mark |wiz_custom_css| for wizeditor replace it-->
<link rel="stylesheet" name="wiz_tmp_editor_style" href="index_files/fonts_780.css"><link type="text/css" rel="stylesheet" id="wiz_code_highlight_link" href="index_files/wiz_code_highlight_143.css"><link rel="stylesheet"  name="wiz_tmp_editor_style" href="index_files/fonts.css"><style id="wiz_custom_css">html, body {            font-size: 15px;        }        body {            font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;            line-height: 1.6;            margin: 0;            padding: 20px 15px;            padding: 1.33rem 1rem;        }        h1, h2, h3, h4, h5, h6 {            margin: 20px 0 10px;            margin: 1.33rem 0 0.667rem;            padding: 0;            font-weight: bold;        }        h1 {            font-size: 21px;            font-size: 1.4rem;        }        h2 {            font-size: 20px;            font-size: 1.33rem;        }        h3 {            font-size: 18px;            font-size: 1.2rem;        }        h4 {            font-size: 17px;            font-size: 1.13rem;        }        h5 {            font-size: 15px;            font-size: 1rem;        }        h6 {            font-size: 15px;            font-size: 1rem;            color: #777777;            margin: 1rem 0;        }        div, p, ul, ol, dl, li {            margin: 0;        }        blockquote, table, pre, code {            margin: 8px 0;        }        ul, ol {            padding-left: 32px;            padding-left: 2.13rem;        }        blockquote {            padding: 0 12px;            padding: 0 0.8rem;        }        blockquote > :first-child {            margin-top: 0;        }        blockquote > :last-child {            margin-bottom: 0;        }        img {            border: 0;            max-width: 100%;            height: auto !important;            margin: 2px 0;        }        table {            border-collapse: collapse;            border: 1px solid #bbbbbb;        }        td, th {            padding: 4px 8px;            border-collapse: collapse;            border: 1px solid #bbbbbb;			        }        @media only screen and (-webkit-max-device-width: 1024px), only screen and (-o-max-device-width: 1024px), only screen and (max-device-width: 1024px), only screen and (-webkit-min-device-pixel-ratio: 3), only screen and (-o-min-device-pixel-ratio: 3), only screen and (min-device-pixel-ratio: 3) {            html, body {                font-size: 17px;            }            body {                line-height: 1.7;                padding: 0.75rem 0.9375rem;                color: #353c47;            }            h1 {                font-size: 2.125rem;            }            h2 {                font-size: 1.875rem;            }            h3 {                font-size: 1.625rem;            }            h4 {                font-size: 1.375rem;            }            h5 {                font-size: 1.125rem;            }            h6 {                color: inherit;            }            ul, ol {                padding-left: 2.5rem;            }            blockquote {                padding: 0 0.9375rem;            }        }</style><style id="wiz_tmp_editor_style" wiz_style= "unsave">html, body {    font-size: 15px;}body {    font-family: Helvetica, 'Hiragino Sans GB', 微软雅黑, 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;    line-height: 1.6;    color: ;    background-color: ;    margin: 0;    padding: 20px 15px;    padding: 1.33rem 1rem;}img{    max-width: 100%;}</style><script type="text/javascript" src="file:///D:\WizNote\WizTools\htmleditor\utils.js" wiz_style="unsave" charset="utf-8"></script><script type="text/javascript" src="file:///D:\WizNote\WizTools\htmleditor\localize.js" wiz_style="unsave" charset="utf-8"></script><script type="text/javascript" src="file:///D:\WizNote\WizTools\htmleditor\core\wizEditorForPc.js" wiz_style="unsave" charset="utf-8"></script><script type="text/javascript" src="file:///D:\WizNote\WizTools\htmleditor\editorHelper.js" wiz_style="unsave" charset="utf-8"></script><script type="text/javascript" src="file:///D:\Wizs\templates\WizTemplate.js" wiz_style="unsave" charset="utf-8"></script></head>

<body spellcheck="false" >一、HashMap概述<div>&nbsp; &nbsp; HashMap基于哈希Map的接口实现，此实现提供所有可选的映射操作，并且允许 键和值为空或null。 （<span data-wiz-span="data-wiz-span" style="color: rgb(255, 0, 0);">不同步和允许使用null之外，HashMap与HashTable大致相同</span>）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br></div><div>&nbsp; &nbsp; 值得质疑的是HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap<div><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><code class="language-java"><span class="typ">Map</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">,</span><span class="typ">Object</span><span class="pun">&gt;</span><span class="pln"> maps  </span><span class="pun">=</span><span class="pln">  </span><span class="typ">Collections</span><span class="pun">.</span><span class="pln">synchronizedMap</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">HashMap</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">,</span><span class="typ">Object</span><span class="pun">&gt;());</span></code></li></ol></pre></div><div><br></div>二、HashMap的数据结构</div><div>&nbsp; &nbsp; HashMap的底层主要是基于<span data-wiz-span="data-wiz-span" style="color: rgb(255, 0, 0);">数组和链表</span>来实现的，它之所以有相当快的查询速度主要是因为它是通过<span data-wiz-span="data-wiz-span" style="color: rgb(255, 0, 0);">计算散列码来决定存储的位置</span>。<span data-wiz-span="data-wiz-span" style="color: rgb(0, 0, 0);">HashMap中主要是通过key的hashCode来计算hash值得，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，就会出现hash冲突。HashMap底层是通过链表来解决hash冲突的。</span></div><div><span data-wiz-span="data-wiz-span" style="color: rgb(0, 0, 0);"><img src="index_files/kt7n2wjk.bmp" border="0"></span></div><div><span data-wiz-span="data-wiz-span" style="color: rgb(0, 0, 0);">紫色代表哈希表，也称也哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的统一位置处，就将其放入到单链表中。</span></div><div><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><code class="language-java"><span class="pun">复制代码</span></code></li><li class="L1"><code class="language-java"></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="com">/** Entry是单向链表。    </span></code></li><li class="L3"><code class="language-java"><span class="com">     * 它是 “HashMap链式存储法”对应的链表。    </span></code></li><li class="L4"><code class="language-java"><span class="com">     *它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数  </span></code></li><li class="L5"><code class="language-java"><span class="com">    **/</span><span class="pln">  </span></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Entry</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> </span><span class="kwd">implements</span><span class="pln"> </span><span class="typ">Map</span><span class="pun">.</span><span class="typ">Entry</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">    </span></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="kwd">final</span><span class="pln"> K key</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L8"><code class="language-java"><span class="pln">        V value</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L9"><code class="language-java"><span class="pln">        </span><span class="com">// 指向下一个节点    </span></code></li><li class="L0"><code class="language-java"><span class="pln">        </span><span class="typ">Entry</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> next</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L1"><code class="language-java"><span class="pln">        </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> hash</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L2"><code class="language-java"><span class="pln">   </span></code></li><li class="L3"><code class="language-java"><span class="pln">        </span><span class="com">// 构造函数。    </span></code></li><li class="L4"><code class="language-java"><span class="pln">        </span><span class="com">// 输入参数包括"哈希值(h)", "键(k)", "值(v)", "下一节点(n)"    </span></code></li><li class="L5"><code class="language-java"><span class="pln">        </span><span class="typ">Entry</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> h</span><span class="pun">,</span><span class="pln"> K k</span><span class="pun">,</span><span class="pln"> V v</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Entry</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">    </span></code></li><li class="L6"><code class="language-java"><span class="pln">            value </span><span class="pun">=</span><span class="pln"> v</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L7"><code class="language-java"><span class="pln">            next </span><span class="pun">=</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L8"><code class="language-java"><span class="pln">            key </span><span class="pun">=</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L9"><code class="language-java"><span class="pln">            hash </span><span class="pun">=</span><span class="pln"> h</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L0"><code class="language-java"><span class="pln">        </span><span class="pun">}</span><span class="pln">    </span></code></li><li class="L1"><code class="language-java"><span class="pln">   </span></code></li><li class="L2"><code class="language-java"><span class="pln">        </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> K getKey</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">    </span></code></li><li class="L3"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> key</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L4"><code class="language-java"><span class="pln">        </span><span class="pun">}</span><span class="pln">    </span></code></li><li class="L5"><code class="language-java"><span class="pln">   </span></code></li><li class="L6"><code class="language-java"><span class="pln">        </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> V getValue</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">    </span></code></li><li class="L7"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> value</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L8"><code class="language-java"><span class="pln">        </span><span class="pun">}</span><span class="pln">    </span></code></li><li class="L9"><code class="language-java"><span class="pln">   </span></code></li><li class="L0"><code class="language-java"><span class="pln">        </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> V setValue</span><span class="pun">(</span><span class="pln">V newValue</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">    </span></code></li><li class="L1"><code class="language-java"><span class="pln">            V oldValue </span><span class="pun">=</span><span class="pln"> value</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L2"><code class="language-java"><span class="pln">            value </span><span class="pun">=</span><span class="pln"> newValue</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L3"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> oldValue</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L4"><code class="language-java"><span class="pln">        </span><span class="pun">}</span><span class="pln">    </span></code></li><li class="L5"><code class="language-java"><span class="pln">   </span></code></li><li class="L6"><code class="language-java"><span class="pln">        </span><span class="com">// 判断两个Entry是否相等    </span></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="com">// 若两个Entry的“key”和“value”都相等，则返回true。    </span></code></li><li class="L8"><code class="language-java"><span class="pln">        </span><span class="com">// 否则，返回false    </span></code></li><li class="L9"><code class="language-java"><span class="pln">        </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> equals</span><span class="pun">(</span><span class="typ">Object</span><span class="pln"> o</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">    </span></code></li><li class="L0"><code class="language-java"><span class="pln">            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!(</span><span class="pln">o </span><span class="kwd">instanceof</span><span class="pln"> </span><span class="typ">Map</span><span class="pun">.</span><span class="typ">Entry</span><span class="pun">))</span><span class="pln">    </span></code></li><li class="L1"><code class="language-java"><span class="pln">                </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L2"><code class="language-java"><span class="pln">            </span><span class="typ">Map</span><span class="pun">.</span><span class="typ">Entry</span><span class="pln"> e </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Map</span><span class="pun">.</span><span class="typ">Entry</span><span class="pun">)</span><span class="pln">o</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L3"><code class="language-java"><span class="pln">            </span><span class="typ">Object</span><span class="pln"> k1 </span><span class="pun">=</span><span class="pln"> getKey</span><span class="pun">();</span><span class="pln">    </span></code></li><li class="L4"><code class="language-java"><span class="pln">            </span><span class="typ">Object</span><span class="pln"> k2 </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">getKey</span><span class="pun">();</span><span class="pln">    </span></code></li><li class="L5"><code class="language-java"><span class="pln">            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">k1 </span><span class="pun">==</span><span class="pln"> k2 </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">k1 </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> k1</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">k2</span><span class="pun">)))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">    </span></code></li><li class="L6"><code class="language-java"><span class="pln">                </span><span class="typ">Object</span><span class="pln"> v1 </span><span class="pun">=</span><span class="pln"> getValue</span><span class="pun">();</span><span class="pln">    </span></code></li><li class="L7"><code class="language-java"><span class="pln">                </span><span class="typ">Object</span><span class="pln"> v2 </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">getValue</span><span class="pun">();</span><span class="pln">    </span></code></li><li class="L8"><code class="language-java"><span class="pln">                </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v1 </span><span class="pun">==</span><span class="pln"> v2 </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v1 </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> v1</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">v2</span><span class="pun">)))</span><span class="pln">    </span></code></li><li class="L9"><code class="language-java"><span class="pln">                    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L0"><code class="language-java"><span class="pln">            </span><span class="pun">}</span><span class="pln">    </span></code></li><li class="L1"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">    </span></code></li><li class="L2"><code class="language-java"><span class="pln">        </span><span class="pun">}</span><span class="pln">    </span></code></li><li class="L3"><code class="language-java"><span class="pln">   </span></code></li><li class="L4"><code class="language-java"><span class="pln">        </span><span class="com">// 实现hashCode()    </span></code></li><li class="L5"><code class="language-java"><span class="pln">        </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> hashCode</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">    </span></code></li><li class="L6"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">key</span><span class="pun">==</span><span class="kwd">null</span><span class="pln">   </span><span class="pun">?</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> key</span><span class="pun">.</span><span class="pln">hashCode</span><span class="pun">())</span><span class="pln"> </span><span class="pun">^</span><span class="pln">    </span></code></li><li class="L7"><code class="language-java"><span class="pln">                   </span><span class="pun">(</span><span class="pln">value</span><span class="pun">==</span><span class="kwd">null</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> value</span><span class="pun">.</span><span class="pln">hashCode</span><span class="pun">());</span><span class="pln">    </span></code></li><li class="L8"><code class="language-java"><span class="pln">        </span><span class="pun">}</span><span class="pln">    </span></code></li><li class="L9"><code class="language-java"><span class="pln">   </span></code></li><li class="L0"><code class="language-java"><span class="pln">        </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> toString</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">    </span></code></li><li class="L1"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> getKey</span><span class="pun">()</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">"="</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> getValue</span><span class="pun">();</span><span class="pln">    </span></code></li><li class="L2"><code class="language-java"><span class="pln">        </span><span class="pun">}</span><span class="pln">    </span></code></li><li class="L3"><code class="language-java"><span class="pln">   </span></code></li><li class="L4"><code class="language-java"><span class="pln">        </span><span class="com">// 当向HashMap中添加元素时，绘调用recordAccess()。    </span></code></li><li class="L5"><code class="language-java"><span class="pln">        </span><span class="com">// 这里不做任何处理    </span></code></li><li class="L6"><code class="language-java"><span class="pln">        </span><span class="kwd">void</span><span class="pln"> recordAccess</span><span class="pun">(</span><span class="typ">HashMap</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> m</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">    </span></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="pun">}</span><span class="pln">    </span></code></li><li class="L8"><code class="language-java"><span class="pln">   </span></code></li><li class="L9"><code class="language-java"><span class="pln">        </span><span class="com">// 当从HashMap中删除元素时，绘调用recordRemoval()。    </span></code></li><li class="L0"><code class="language-java"><span class="pln">        </span><span class="com">// 这里不做任何处理    </span></code></li><li class="L1"><code class="language-java"><span class="pln">        </span><span class="kwd">void</span><span class="pln"> recordRemoval</span><span class="pun">(</span><span class="typ">HashMap</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> m</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">    </span></code></li><li class="L2"><code class="language-java"><span class="pln">        </span><span class="pun">}</span><span class="pln">    </span></code></li><li class="L3"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li></ol></pre></div><div>HashMap其实就是一个Entry数组，Entry对象中包含了键和值，其中next也是一个Entry对象，他就是用来处理hash冲突的，形成一个链表。</div><div><br></div><div>三、HashMap源码分析</div><div>&nbsp; &nbsp; 1、关键属性<br></div><div>&nbsp; &nbsp; 先看看hashMap类中的一些关键属性：<br></div><div> &nbsp; &nbsp;transient是类型修饰符，只能用来修饰字段。在对象序列化的过程中，标记为transient的变量不会被序列化。<br></div><div><div><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">transient</span><span class="pln"> </span><span class="typ">Entry</span><span class="pun">[]</span><span class="pln"> table</span><span class="pun">;</span><span class="com">//存储元素的实体数组</span></code></li><li class="L1"><code class="language-java"><span class="pln"> </span></code></li><li class="L2"><code class="language-java"><span class="kwd">transient</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> size</span><span class="pun">;</span><span class="com">//存放元素的个数</span></code></li><li class="L3"><code class="language-java"><span class="pln"> </span></code></li><li class="L4"><code class="language-java"><span class="kwd">int</span><span class="pln"> threshold</span><span class="pun">;</span><span class="pln"> </span><span class="com">//临界值   当实际大小超过临界值时，会进行扩容threshold = 加载因子*容量</span></code></li><li class="L5"><code class="language-java"></code></li><li class="L6"><code class="language-java"><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> loadFactor</span><span class="pun">;</span><span class="pln"> </span><span class="com">//加载因子</span></code></li><li class="L7"><code class="language-java"><span class="pln"> </span></code></li><li class="L8"><code class="language-java"><span class="kwd">transient</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> modCount</span><span class="pun">;</span><span class="com">//被修改的次数</span></code></li></ol></pre></div><div>其中 <span data-wiz-span="data-wiz-span" style="color: rgb(255, 0, 0);">loadFactor加载因子是表示Hash表中元素的填满的程度</span>。</div><div>例：加载因子越大，填满的元素越多，好处是，空间利用率高了，但是冲突的机会加大了，链表长度会越来越长，查找效率降低。</div><div>反之，加载因子越小，填满的元素越少，好处是冲突的机会减少了，但是空间浪费多了，表中的数据将过于稀疏（很多空间还没使用，就开始扩容了）</div><div>冲突的机会越大，则查找的成本越高。</div><div>因此，必须在”冲突的机会“与”空间利用率“之间寻找一种平衡与折中，这种平衡与这种本质上市数据结构中有名的"时-空"矛盾的平衡与折中。</div><div>&nbsp; &nbsp; 如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点，相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点，不过一般都不用去设置它，让它取<span data-wiz-span="data-wiz-span" style="color: rgb(255, 0, 0);">默认值0.75</span>就好了。<br></div><div>&nbsp; &nbsp; 2、构造方法<br></div><div>&nbsp; 下面看看HashMap的几个构造方法：<br></div><div>&nbsp; &nbsp;&nbsp;<div><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">public</span><span class="pln"> </span><span class="typ">HashMap</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> initialCapacity</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> loadFactor</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">        </span><span class="com">//确保数字合法</span></code></li><li class="L2"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">initialCapacity </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span></code></li><li class="L3"><code class="language-java"><span class="pln">            </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">IllegalArgumentException</span><span class="pun">(</span><span class="str">"Illegal initial capacity: "</span><span class="pln"> </span><span class="pun">+</span></code></li><li class="L4"><code class="language-java"><span class="pln">                                              initialCapacity</span><span class="pun">);</span></code></li><li class="L5"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">initialCapacity </span><span class="pun">&gt;</span><span class="pln"> MAXIMUM_CAPACITY</span><span class="pun">)</span></code></li><li class="L6"><code class="language-java"><span class="pln">            initialCapacity </span><span class="pun">=</span><span class="pln"> MAXIMUM_CAPACITY</span><span class="pun">;</span></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">loadFactor </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> </span><span class="typ">Float</span><span class="pun">.</span><span class="pln">isNaN</span><span class="pun">(</span><span class="pln">loadFactor</span><span class="pun">))</span></code></li><li class="L8"><code class="language-java"><span class="pln">            </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">IllegalArgumentException</span><span class="pun">(</span><span class="str">"Illegal load factor: "</span><span class="pln"> </span><span class="pun">+</span></code></li><li class="L9"><code class="language-java"><span class="pln">                                              loadFactor</span><span class="pun">);</span></code></li><li class="L0"><code class="language-java"></code></li><li class="L1"><code class="language-java"><span class="pln">        </span><span class="com">// Find a power of 2 &gt;= initialCapacity</span></code></li><li class="L2"><code class="language-java"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> capacity </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">   </span><span class="com">//初始容量</span></code></li><li class="L3"><code class="language-java"><span class="pln">        </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">capacity </span><span class="pun">&lt;</span><span class="pln"> initialCapacity</span><span class="pun">)</span><span class="pln">   </span><span class="com">//确保容量为2的n次幂，使capacity为大于initialCapacity的最小的2的n次幂</span></code></li><li class="L4"><code class="language-java"><span class="pln">            capacity </span><span class="pun">&lt;&lt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"></code></li><li class="L6"><code class="language-java"><span class="pln">        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">loadFactor </span><span class="pun">=</span><span class="pln"> loadFactor</span><span class="pun">;</span></code></li><li class="L7"><code class="language-java"><span class="pln">        threshold </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)(</span><span class="pln">capacity </span><span class="pun">*</span><span class="pln"> loadFactor</span><span class="pun">);</span></code></li><li class="L8"><code class="language-java"><span class="pln">        table </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Entry</span><span class="pun">[</span><span class="pln">capacity</span><span class="pun">];</span></code></li><li class="L9"><code class="language-java"><span class="pln">       init</span><span class="pun">();</span></code></li><li class="L0"><code class="language-java"><span class="pln">   </span><span class="pun">}</span></code></li><li class="L1"><code class="language-java"></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">HashMap</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> initialCapacity</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code class="language-java"><span class="pln">        </span><span class="kwd">this</span><span class="pun">(</span><span class="pln">initialCapacity</span><span class="pun">,</span><span class="pln"> DEFAULT_LOAD_FACTOR</span><span class="pun">);</span></code></li><li class="L4"><code class="language-java"><span class="pln">   </span><span class="pun">}</span></code></li><li class="L5"><code class="language-java"></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">HashMap</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L7"><code class="language-java"><span class="pln">        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">loadFactor </span><span class="pun">=</span><span class="pln"> DEFAULT_LOAD_FACTOR</span><span class="pun">;</span></code></li><li class="L8"><code class="language-java"><span class="pln">        threshold </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)(</span><span class="pln">DEFAULT_INITIAL_CAPACITY </span><span class="pun">*</span><span class="pln"> DEFAULT_LOAD_FACTOR</span><span class="pun">);</span></code></li><li class="L9"><code class="language-java"><span class="pln">        table </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Entry</span><span class="pun">[</span><span class="pln">DEFAULT_INITIAL_CAPACITY</span><span class="pun">];</span></code></li><li class="L0"><code class="language-java"><span class="pln">       init</span><span class="pun">();</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li></ol></pre></div><div><br></div></div>我们可以看到在构造HashMap的时候如果我们指定了加载因子和初始容量的话就调用第一个构造方法，否则的话就是默认的，默认初始容量为16，默认加载因子是0.75.我们可以看到上面13-15这个代码的作用是确保容量为2的n次幂，使capacity为大于initCapacity的最小的2的n次幂。</div><div><br></div><div>&nbsp; &nbsp; 3、存储数据<br></div><div>&nbsp; &nbsp; 下面看看HashMap存储数据的过程是怎样的，首先看看HashMap的put方法<br></div><div>&nbsp; &nbsp;&nbsp;<div><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">public</span><span class="pln"> V put</span><span class="pun">(</span><span class="pln">K key</span><span class="pun">,</span><span class="pln"> V value</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">     </span><span class="com">// 若“key为null”，则将该键值对添加到table[0]中。</span></code></li><li class="L2"><code class="language-java"><span class="pln">         </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">key </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span></code></li><li class="L3"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> putForNullKey</span><span class="pun">(</span><span class="pln">value</span><span class="pun">);</span></code></li><li class="L4"><code class="language-java"><span class="pln">     </span><span class="com">// 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。</span></code></li><li class="L5"><code class="language-java"><span class="pln">         </span><span class="kwd">int</span><span class="pln"> hash </span><span class="pun">=</span><span class="pln"> hash</span><span class="pun">(</span><span class="pln">key</span><span class="pun">.</span><span class="pln">hashCode</span><span class="pun">());</span></code></li><li class="L6"><code class="language-java"><span class="pln">     </span><span class="com">//搜索指定hash值在对应table中的索引</span></code></li><li class="L7"><code class="language-java"><span class="pln">         </span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> indexFor</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">,</span><span class="pln"> table</span><span class="pun">.</span><span class="pln">length</span><span class="pun">);</span></code></li><li class="L8"><code class="language-java"><span class="pln">     </span><span class="com">// 循环遍历Entry数组,若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！</span></code></li><li class="L9"><code class="language-java"><span class="pln">         </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Entry</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> e </span><span class="pun">=</span><span class="pln"> table</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln"> e </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln"> e </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">next</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span></code></li><li class="L0"><code class="language-java"><span class="pln">             </span><span class="typ">Object</span><span class="pln"> k</span><span class="pun">;</span></code></li><li class="L1"><code class="language-java"><span class="pln">              </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">hash </span><span class="pun">==</span><span class="pln"> hash </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">((</span><span class="pln">k </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> key </span><span class="pun">||</span><span class="pln"> key</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">k</span><span class="pun">)))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="com">//如果key相同则覆盖并返回旧值</span></code></li><li class="L2"><code class="language-java"><span class="pln">                  V oldValue </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">value</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"><span class="pln">                 e</span><span class="pun">.</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> value</span><span class="pun">;</span></code></li><li class="L4"><code class="language-java"><span class="pln">                 e</span><span class="pun">.</span><span class="pln">recordAccess</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span></code></li><li class="L5"><code class="language-java"><span class="pln">                 </span><span class="kwd">return</span><span class="pln"> oldValue</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"><span class="pln">              </span><span class="pun">}</span></code></li><li class="L7"><code class="language-java"><span class="pln">         </span><span class="pun">}</span></code></li><li class="L8"><code class="language-java"><span class="pln">     </span><span class="com">//修改次数+1</span></code></li><li class="L9"><code class="language-java"><span class="pln">         modCount</span><span class="pun">++;</span></code></li><li class="L0"><code class="language-java"><span class="pln">     </span><span class="com">//将key-value添加到table[i]处</span></code></li><li class="L1"><code class="language-java"><span class="pln">     addEntry</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">,</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> value</span><span class="pun">,</span><span class="pln"> i</span><span class="pun">);</span></code></li><li class="L2"><code class="language-java"><span class="pln">     </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"><span class="pun">}</span></code></li><li class="L3"><code class="language-java"><span class="pun">private V putForNullKey(V value) {
        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {
            if (e.key == null) {   //如果有key为null的对象存在，则覆盖掉
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
           }
       }
        modCount++;
        addEntry(0, null, value, 0); //如果键为null的话，则hash值为0
        return null;
    }</span></code></li><li class="L3"><code class="language-java"><span class="pun"><pre><font color="#008000" face="comic sans ms, sans-serif"><span style="font-size: 16px;">//计算hash值的方法 通过键的hashCode来计算
    static int hash(int h) {
        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
    }</span></font><span style="font-size: 13.3333px;"><br></span></pre></span></code></li><li class="L3"><pre><pre><span style="font-family: 'comic sans ms', sans-serif; font-size: 16px;"><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> indexFor(<span style="color: #0000ff;">int</span> h, <span style="color: #0000ff;">int</span> length) { <span style="color: #008000;">//</span><span style="color: #008000;">根据hash值和数组长度算出索引值</span>
        <span style="color: #0000ff;">return</span> h &amp; (length-<span style="color: #800080;">1</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">这里不能随便算取，用hash&amp;(length-1)是有原因的，这样可以确保算出来的索引是在数组大小范围内，不会超出</span></span></pre><pre><span style="font-family: 'comic sans ms', sans-serif; font-size: 16px;">}</span></pre></pre></li></ol></pre></div></div><div><span data-wiz-span="data-wiz-span"><div style="color: rgb(0, 0, 0);">&nbsp;</div><div style="color: rgb(0, 0, 0);"></div><div><div>每个Map.Entry起始就是一个key-value对。从上面程序中可以看出：当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅是根据key来计算并决定每个Entry的存储位置。这样额说明了前面的结论：我们完全可以把Map集合中的Value当成key的附属，当系统决定了key的存储位置之后，value随之保存在哪里即可。</div></div><div>一般对哈希表的散列很自然地会想到用hash值对length取模（除法散列法），Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&amp;（length-1）的方法来代替取模，同样实现了均匀地散列，但效率要高很多，这也是hashMap在HashTable上的一个优化。</div><div><br></div><div>Q:为什么哈希表的容量一定是2的整数次幂？</div><div>A：length为2的整数次幂方便了 h&amp;（length-1）对length的取模，这样便保证了散列的均匀，同事也提升了效率；其次，legnth为2的整数次幂，在length-1后必为奇数，奇数的最后一位是1，这样保证了h&amp;(length-1)de最后一位可能为0也可能为1，即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果legnth为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;(length-1)的最后一位肯定为0 ，即只为偶数，这样人和hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间，因此，length取2的整数次幂，是为了不同hash值发生碰撞的概率较小，这样就能是元素在哈希表中均匀的散列。</div><div><img src="index_files/d80d35e0-a5cd-4af5-bd17-3228f7db82da.png" border="0" class=""><div>&nbsp;</div><p class="p0"><span style="font-family: 'comic sans ms', sans-serif; font-size: 16px;">从上面的例子中可以看出：当它们和15-1（1110）“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链&nbsp;表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hash值会与15-1（1110）进行“与”，那么&nbsp;最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1，这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int&nbsp;h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。</span></p><p class="p0"><span style="font-family: 'comic sans ms', sans-serif; font-size: 16px;">　　&nbsp;所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。<br></span></p><div style="color:gray"><br></div><div style="color:gray">&nbsp; &nbsp;&nbsp;<span data-wiz-span="data-wiz-span" style="font-family:微软雅黑;color:rgb(0, 0, 0)">根据上面put方法的源代码可以看出，当程序视图将一个key-value对放入到HashMap中时，程序首先根据该key的hashCode（）返回值决定该Entry的存储位置：如果两个Entry的key的hashCode（0返回值相同，那它们的存储位置相同。如果这两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有Entry的value，但key不会覆盖。如果这两个Entry的key通过equals比较返回false，新添加的Entry将与集合中缘由Entry形成Entry链，而且新添加的Entry位于Entry链的头部--具体说明继续看addEntry（）方法的说明。</span><br></div><p></p></div><div><br></div><div><div><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">void</span><span class="pln"> addEntry</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> hash</span><span class="pun">,</span><span class="pln"> K key</span><span class="pun">,</span><span class="pln"> V value</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> bucketIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">        </span><span class="typ">Entry</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> e </span><span class="pun">=</span><span class="pln"> table</span><span class="pun">[</span><span class="pln">bucketIndex</span><span class="pun">];</span><span class="pln"> </span><span class="com">//如果要加入的位置有值，将该位置原先的值设置为新entry的next,也就是新entry链表的下一个节点</span></code></li><li class="L2"><code class="language-java"><span class="pln">        table</span><span class="pun">[</span><span class="pln">bucketIndex</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Entry</span><span class="pun">&lt;&gt;(</span><span class="pln">hash</span><span class="pun">,</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> value</span><span class="pun">,</span><span class="pln"> e</span><span class="pun">);</span></code></li><li class="L3"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">size</span><span class="pun">++</span><span class="pln"> </span><span class="pun">&gt;=</span><span class="pln"> threshold</span><span class="pun">)</span><span class="pln"> </span><span class="com">//如果大于临界值就扩容</span></code></li><li class="L4"><code class="language-java"><span class="pln">             resize</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> table</span><span class="pun">.</span><span class="pln">length</span><span class="pun">);</span><span class="pln"> </span><span class="com">//以2的倍数扩容</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li></ol></pre></div><div>参数bucketIndex就是indexFor函数计算出来的索引值，第2行代码是取得数组中索引为bucketIndex的Entry对象，第3行就是用hash、key、value构建一个新的Entry对象放到索引为bucketIndex的位置，并且将该位置原先的对象设置为新对象的next构成链表。</div><div>&nbsp; &nbsp; 第4 5就是判断put后size是否达到了临界值threshold，如果达到了临界值就需要进行扩容，HashMap扩容试试扩为原来的两倍。<br></div><div>&nbsp; &nbsp;&nbsp;<br></div><div>4、调整大小</div><div>resize（） 方法如下：</div><div>冲洗你调整HashMap的大小，newCapacity是调整后的单位</div><div><div><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">void</span><span class="pln"> resize</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> newCapacity</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">        </span><span class="typ">Entry</span><span class="pun">[]</span><span class="pln"> oldTable </span><span class="pun">=</span><span class="pln"> table</span><span class="pun">;</span></code></li><li class="L2"><code class="language-java"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> oldCapacity </span><span class="pun">=</span><span class="pln"> oldTable</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span></code></li><li class="L3"><code class="language-java"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">oldCapacity </span><span class="pun">==</span><span class="pln"> MAXIMUM_CAPACITY</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L4"><code class="language-java"><span class="pln">            threshold </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Integer</span><span class="pun">.</span><span class="pln">MAX_VALUE</span><span class="pun">;</span></code></li><li class="L5"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pun">;</span></code></li><li class="L6"><code class="language-java"><span class="pln">       </span><span class="pun">}</span></code></li><li class="L7"><code class="language-java"></code></li><li class="L8"><code class="language-java"><span class="pln">        </span><span class="typ">Entry</span><span class="pun">[]</span><span class="pln"> newTable </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Entry</span><span class="pun">[</span><span class="pln">newCapacity</span><span class="pun">];</span></code></li><li class="L9"><code class="language-java"><span class="pln">        transfer</span><span class="pun">(</span><span class="pln">newTable</span><span class="pun">);</span><span class="com">//用来将原先table的元素全部移到newTable里面</span></code></li><li class="L0"><code class="language-java"><span class="pln">        table </span><span class="pun">=</span><span class="pln"> newTable</span><span class="pun">;</span><span class="pln">  </span><span class="com">//再将newTable赋值给table</span></code></li><li class="L1"><code class="language-java"><span class="pln">        threshold </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)(</span><span class="pln">newCapacity </span><span class="pun">*</span><span class="pln"> loadFactor</span><span class="pun">);</span><span class="com">//重新计算临界值</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="pun">}</span></code></li></ol></pre></div><div>新建了一个HashMap底层数组，上面大妈中第十行为调用transfer方法，将HashMap的全部元素添加到新的HashMap中，并重新计算元素在新的数组中的索引位置</div><div>当HashMap中的元素越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对hashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在Hashmap数组扩容之后，最小号心跟那个的点就出现了：原数组中的数据必须重新计算其在新数组的位置，并放进去这就是resize。</div><div>&nbsp; &nbsp; 那么hashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个这种的取值。也就是说，默认情况下，数组大小为16，那么当hashMap中的元素个数超过16*0.75=12时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，扩容是需要进行数组复制的，复制数组ushi非常消耗心性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。<br></div></div><div><div><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><code class="language-java"></code></li><li class="L1"><code class="language-java"><span class="lit">public</span><span class="pln"> V get</span><span class="pun">(</span><span class="typ">Object</span><span class="pln"> key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">   </span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">key </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln">   </span></code></li><li class="L3"><code class="language-java"><span class="pln">        </span><span class="kwd">return</span><span class="pln"> getForNullKey</span><span class="pun">();</span><span class="pln">   </span></code></li><li class="L4"><code class="language-java"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> hash </span><span class="pun">=</span><span class="pln"> hash</span><span class="pun">(</span><span class="pln">key</span><span class="pun">.</span><span class="pln">hashCode</span><span class="pun">());</span><span class="pln">   </span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Entry</span><span class="pun">&lt;</span><span class="pln">K</span><span class="pun">,</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> e </span><span class="pun">=</span><span class="pln"> table</span><span class="pun">[</span><span class="pln">indexFor</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">,</span><span class="pln"> table</span><span class="pun">.</span><span class="pln">length</span><span class="pun">)];</span><span class="pln"> </span></code><span class="pln" style="font-size: 13px;"> e </span><span class="pun" style="font-size: 13px;">!=</span><span class="pln" style="font-size: 13px;"> </span><span class="kwd" style="font-size: 13px;">null</span><span class="pun" style="font-size: 13px;">;</span><span class="pln" style="font-size: 13px;"> </span><span class="pln" style="font-size: 13px;"> e </span><span class="pun" style="font-size: 13px;">=</span><span class="pln" style="font-size: 13px;"> e</span><span class="pun" style="font-size: 13px;">.</span><span class="pln" style="font-size: 13px;">next</span><span class="pun" style="font-size: 13px;">)</span><span class="pln" style="font-size: 13px;"> </span><span class="pun" style="font-size: 13px;">{</span><span class="pln" style="font-size: 13px;">   </span></li><li class="L8"><code class="language-java"><span class="pln">        </span><span class="typ">Object</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">  &nbsp;</span></code></li><li class="L8"><span class="pln" style="font-size: 13px;">        </span><span class="kwd" style="font-size: 13px;">if</span><span class="pln" style="font-size: 13px;"> </span><span class="pun" style="font-size: 13px;">(</span><span class="pln" style="font-size: 13px;">e</span><span class="pun" style="font-size: 13px;">.</span><span class="pln" style="font-size: 13px;">hash </span><span class="pun" style="font-size: 13px;">==</span><span class="pln" style="font-size: 13px;"> hash </span><span class="pun" style="font-size: 13px;">&amp;&amp;</span><span class="pln" style="font-size: 13px;"> </span><span class="pun" style="font-size: 13px;">((</span><span class="pln" style="font-size: 13px;">k </span><span class="pun" style="font-size: 13px;">=</span><span class="pln" style="font-size: 13px;"> e</span><span class="pun" style="font-size: 13px;">.</span><span class="pln" style="font-size: 13px;">key</span><span class="pun" style="font-size: 13px;">)</span><span class="pln" style="font-size: 13px;"> </span><span class="pun" style="font-size: 13px;">==</span><span class="pln" style="font-size: 13px;"> key </span><span class="pun" style="font-size: 13px;">||</span><span class="pln" style="font-size: 13px;"> key</span><span class="pun" style="font-size: 13px;">.</span><span class="pln" style="font-size: 13px;">equals</span><span class="pun" style="font-size: 13px;">(</span><span class="pln" style="font-size: 13px;">k</span><span class="pun" style="font-size: 13px;">)))</span><span class="pln" style="font-size: 13px;">   </span></li><li class="L0"><code class="language-java"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">value</span><span class="pun">;</span><span class="pln">   </span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="pun">}</span><span class="pln">   </span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">   </span></code></li><li class="L3"><code class="language-java"><span class="pun">}</span></code></li></ol></pre></div><div>从HashMap中get元素是，首先计算key的hashCode找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</div><div>6、HashMap的性能参数：</div><div>&nbsp; &nbsp; HashMap包含如下几个构造器：<br></div><div>&nbsp; &nbsp; HashMap()：构建一个初始容量为16，负载因子为0.75的hashmap<br></div><div>&nbsp; &nbsp; HashMap(int initialCapacity):构建一个初始容量为initalCapacity，负载因子为0.75的HashMap<br></div><div>&nbsp; &nbsp; HashMap(int initalCapacity, float loadFactor):以指定初始容量、指定的负载因子创建一个hashMap<br></div><div>&nbsp; &nbsp; HashMap的基础构造器HashMap(int initialCapacity,float loadFactor)带有两个参数，它们是初始容量initalcapacity和加载因子laodFactor</div><div>&nbsp; &nbsp; initialCapacity:HashMap的最大容量，底层数组的长度。<br></div><div>&nbsp; &nbsp; loadFactor:负载因子laodFacotr定义为：散列表的实际元素数目（n)/散列表的容量（m)<br></div><div>&nbsp; &nbsp; 负载因子衡量的是一个散列表的空间的使用程度，负载因子越大标识散列表的填装程度越高，反之越小。对于使用链表法的散列表来说查找一个元素的平均时间是O（1+a)<br></div><div>,因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的效率降低，如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。</div><div>&nbsp; &nbsp; HashMap的实现中，通过threshold字段来判断HashMap的最大容量：<br></div><div>&nbsp; &nbsp; threshold = （int)（capacity * loadFactor)&nbsp;<br></div><div>&nbsp; &nbsp; 结合负载因子的定义公式可知，threshold就是再此loadFactor还ecapacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子。默认的负载因子0.75是对空间和效率的一个平衡选择。当容量超出此最大容量时，resize后的HashMap容量就是原容量的两倍。<br></div><div><br></div><div>&nbsp; &nbsp;&nbsp;<br></div><div>&nbsp; &nbsp;&nbsp;<br></div><br></div><div><br></div><br></div><div><br></div><div><br></div></span></div></body></html>